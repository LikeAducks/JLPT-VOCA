<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>JLPT 단어 암기장</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            -webkit-tap-highlight-color: transparent; /* Disable tap highlight on mobile */
        }
        .screen { display: none; animation: fadeIn 0.3s ease-in-out; }
        .screen.active { display: flex; }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        /* Accordion styles */
        details > summary { list-style: none; }
        details > summary::-webkit-details-marker { display: none; }
        details .icon { transition: transform 0.2s; }
        details[open] .icon { transform: rotate(90deg); }
        
        /* Word item interaction styles */
        .word-item {
            transition: transform 0.3s ease, background-color 0.3s ease;
            position: relative;
        }
        .word-item.swiping {
            transition: transform 0.2s ease-out;
            transform: translateX(-60px);
        }
        .word-item.is-wrong-note {
            background-color: #fed7aa; /* Tailwind orange-200 */
        }

        /* Test item specific styles */
        .test-item-content .notation { display: none; }
        .test-item-content.revealed .notation { display: inline; }
        .test-item-content.revealed .placeholder { display: none; }
    </style>
</head>
<body class="bg-slate-50 text-slate-800">

    <div id="app-container" class="max-w-xl mx-auto min-h-screen bg-white shadow-lg">
        
        <!-- Loading Screen -->
        <div id="loading-screen" class="screen active flex-col justify-center items-center p-6 min-h-screen">
            <svg class="animate-spin h-10 w-10 text-sky-600 mb-4" xmlns="http://www.w.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <h1 class="text-xl font-bold text-sky-700">단어장 로딩 중...</h1>
            <p class="text-slate-500 mt-2">N5, N4, N3 단어를 준비하고 있어요.</p>
        </div>

        <!-- Main Screen -->
        <div id="main-screen" class="screen flex-col justify-center items-center p-6 min-h-screen space-y-6">
            <div class="text-center">
                <h1 class="text-4xl font-bold text-sky-700">JLPT 단어장</h1>
                <p class="text-slate-500 mt-2">암기 또는 테스트를 선택하세요.</p>
            </div>
            <div class="w-full max-w-xs space-y-4">
                <button data-target="memorize-select-screen" class="main-nav-btn w-full bg-sky-600 text-white font-bold py-4 px-4 rounded-lg shadow-md hover:bg-sky-700 transition-transform transform hover:scale-105 active:scale-100">암기하기</button>
                <button data-target="test-select-screen" class="main-nav-btn w-full bg-emerald-500 text-white font-bold py-4 px-4 rounded-lg shadow-md hover:bg-emerald-600 transition-transform transform hover:scale-105 active:scale-100">테스트</button>
            </div>
        </div>

        <!-- Memorize: Level Select Screen -->
        <div id="memorize-select-screen" class="screen flex-col p-4 min-h-screen">
            <header class="flex items-center mb-4 sticky top-0 bg-white py-2 z-10">
                <button class="back-btn p-2 rounded-full hover:bg-slate-100" data-target="main-screen"><svg xmlns="http://www.w.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                <h2 class="text-xl font-bold mx-auto pr-8">암기하기</h2>
            </header>
            <div class="space-y-2">
                <!-- Accordion UI for levels and wrong notes will be built here -->
            </div>
        </div>
        
        <!-- Memorize: Word List Screen -->
        <div id="memorize-word-list-screen" class="screen flex-col min-h-screen">
            <header class="flex items-center p-4 sticky top-0 bg-white shadow-sm z-10">
                <button class="back-btn p-2 rounded-full hover:bg-slate-100" data-target="memorize-select-screen"><svg xmlns="http://www.w.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                <h2 id="word-list-title" class="text-xl font-bold mx-auto pr-8"></h2>
            </header>
            <div class="flex-grow p-4 space-y-2" id="memorize-list-container">
                <!-- Word list will be dynamically generated here -->
            </div>
        </div>

        <!-- Test: Level Select Screen -->
        <div id="test-select-screen" class="screen flex-col p-4 min-h-screen">
            <header class="flex items-center mb-4 sticky top-0 bg-white py-2">
                <button class="back-btn p-2 rounded-full hover:bg-slate-100" data-target="main-screen"><svg xmlns="http://www.w.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                <h2 class="text-xl font-bold mx-auto pr-8">테스트 레벨 선택</h2>
            </header>
            <div id="test-level-grid" class="grid grid-cols-2 gap-4 text-center">
                <!-- Test level buttons will be dynamically generated here -->
            </div>
        </div>

        <!-- Test: Range Select Screen -->
        <div id="test-range-select-screen" class="screen flex-col p-4 min-h-screen">
             <header class="flex items-center mb-4 sticky top-0 bg-white py-2">
                <button class="back-btn p-2 rounded-full hover:bg-slate-100" data-target="test-select-screen"><svg xmlns="http://www.w.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                <h2 id="test-range-title" class="text-xl font-bold mx-auto pr-8">테스트 범위 설정</h2>
            </header>
            <div class="flex-grow flex flex-col justify-center items-center px-4 space-y-6">
                <div class="w-full">
                    <label id="start-range-label" for="start-range" class="block font-medium mb-1">시작 일차</label>
                    <input type="number" id="start-range" value="1" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
                </div>
                <div class="w-full">
                    <label id="end-range-label" for="end-range" class="block font-medium mb-1">끝 일차</label>
                    <input type="number" id="end-range" value="1" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-sky-500 focus:border-sky-500">
                </div>
                <button id="start-test-btn" class="w-full bg-emerald-500 text-white font-bold py-4 px-4 rounded-lg shadow-md hover:bg-emerald-600 transition-transform transform hover:scale-105 active:scale-100">테스트 시작</button>
            </div>
        </div>

        <!-- Test: Word List Screen -->
        <div id="test-word-list-screen" class="screen flex-col min-h-screen">
            <header class="flex items-center p-4 sticky top-0 bg-white shadow-sm z-10">
                <button class="back-btn p-2 rounded-full hover:bg-slate-100" data-target="test-range-select-screen"><svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></button>
                <h2 id="test-list-title" class="text-xl font-bold mx-auto pr-8">테스트</h2>
            </header>
            <div class="p-4 w-full">
                <p class="text-center text-slate-500 bg-slate-100 p-3 rounded-lg mb-4">단어를 클릭해서 정답 확인, 밀어서 오답노트 관리</p>
                <div id="test-list-container" class="space-y-2">
                    <!-- Test words will be dynamically generated here -->
                </div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- State Variables ---
        const state = {
            words: { n5: [], n4: [], n3: [] },
            wrongWords: [],
            pendingWrongWordChanges: {}, // Temporary changes for the current screen
        };
        const WRONG_WORDS_KEY = 'jlptWrongWords';
        const DAYS_PER_LEVEL = 30;
        const WRONG_NOTE_CHUNK_SIZE = 20;
        const LEVELS = ['n5', 'n4', 'n3'];

        // --- DOM Elements ---
        const screens = document.querySelectorAll('.screen');
        const mainNavBtns = document.querySelectorAll('.main-nav-btn');
        const backBtns = document.querySelectorAll('.back-btn');
        const memorizeSelectContainer = document.querySelector('#memorize-select-screen .space-y-2');
        const testLevelGrid = document.getElementById('test-level-grid');
        let currentTestLevel = '';

        // --- Data Loading & Initialization ---
        async function loadAllData() {
            try {
                const fileNames = { n5: 'N5.csv', n4: 'N4.csv', n3: 'N3.csv' };
                const fetchPromises = LEVELS.map(level => 
                    fetch(fileNames[level]).then(res => {
                        if (!res.ok) throw new Error(`'${fileNames[level]}' 파일을 찾을 수 없습니다. (HTTP ${res.status})`);
                        return res.text();
                    })
                );
                
                const [n5CSV, n4CSV, n3CSV] = await Promise.all(fetchPromises);
                
                state.words.n5 = parseCSV(n5CSV, 'N5');
                state.words.n4 = parseCSV(n4CSV, 'N4');
                state.words.n3 = parseCSV(n3CSV, 'N3');

                loadWrongWords();
                initializeApp();
            } catch (error) {
                console.error("Failed to load word files:", error);
                document.getElementById('loading-screen').innerHTML = `<h1 class="text-xl font-bold text-red-700">오류 발생</h1><p class="text-slate-500 mt-2">${error.message}<br>GitHub 저장소에 파일이 정확히 올라갔는지 확인해주세요.</p>`;
            }
        }

        function parseCSV(text, level) {
            return text.trim().replace(/\r/g, '').split('\n').slice(1).map(line => {
                const [day, , meaning, notation] = line.split(',');
                return {
                    day: day.replace('일차', '').trim(),
                    meaning: meaning?.replace(/"/g, '') || '',
                    notation: notation?.replace(/"/g, '') || '',
                    level: level,
                    id: `${level}-${meaning}`
                };
            }).filter(w => w.day && w.meaning && w.notation);
        }
        
        function initializeApp() {
            setupEventListeners();
            buildMemorizeScreen();
            buildTestSelectScreen();
            showScreen('main-screen');
        }
        
        loadAllData();

        // --- Screen & UI Builders ---
        function showScreen(screenId) {
            screens.forEach(s => s.classList.remove('active'));
            document.getElementById(screenId).classList.add('active');
            window.scrollTo(0, 0);
        }

        function buildMemorizeScreen() {
            const levelsHtml = LEVELS.map(level => `
                <details class="bg-slate-50 rounded-lg">
                    <summary class="flex justify-between items-center p-4 font-semibold cursor-pointer">
                        ${level.toUpperCase()} 단어
                        <svg class="icon h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                    </summary>
                    <div class="grid grid-cols-4 sm:grid-cols-5 gap-3 p-4 border-t border-slate-200">
                        ${Array.from({ length: DAYS_PER_LEVEL }, (_, i) => `<button data-level="${level}" data-day="${i + 1}" class="memorize-day-btn p-3 border rounded-lg shadow-sm bg-white hover:bg-sky-100">${i + 1}일차</button>`).join('')}
                    </div>
                </details>
            `).join('');

            const wrongNoteHtml = `
                <details class="bg-slate-50 rounded-lg">
                    <summary class="flex justify-between items-center p-4 font-semibold cursor-pointer">
                        오답노트 (${state.wrongWords.length}개)
                        <svg class="icon h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg>
                    </summary>
                    <div id="wrong-note-chunks" class="grid grid-cols-3 sm:grid-cols-4 gap-3 p-4 border-t border-slate-200">
                        ${buildWrongNoteChunks()}
                    </div>
                </details>
            `;
            memorizeSelectContainer.innerHTML = levelsHtml + wrongNoteHtml;
        }

        function buildWrongNoteChunks() {
            if (state.wrongWords.length === 0) return '<p class="col-span-full text-center text-slate-500">오답노트가 비어있습니다.</p>';
            const chunkCount = Math.ceil(state.wrongWords.length / WRONG_NOTE_CHUNK_SIZE);
            return Array.from({ length: chunkCount }, (_, i) => {
                const start = i * WRONG_NOTE_CHUNK_SIZE;
                const end = start + WRONG_NOTE_CHUNK_SIZE - 1;
                return `<button data-start="${start}" data-end="${end}" class="memorize-wrong-btn p-3 border rounded-lg shadow-sm bg-white hover:bg-amber-100">${start + 1}-${Math.min(end + 1, state.wrongWords.length)}</button>`;
            }).join('');
        }
        
        function buildTestSelectScreen() {
             const levels = [...LEVELS, 'wrong-note'];
             testLevelGrid.innerHTML = levels.map(level => `
                <button data-level="${level}" class="test-level-btn p-6 border rounded-lg shadow-sm font-bold text-lg ${level === 'wrong-note' ? 'bg-amber-400' : 'bg-sky-400'} text-white hover:opacity-90">
                    ${level === 'wrong-note' ? '오답노트' : level.toUpperCase()}
                </button>
            `).join('');
        }

        // --- Wrong Note Management ---
        function loadWrongWords() {
            const stored = localStorage.getItem(WRONG_WORDS_KEY);
            state.wrongWords = stored ? JSON.parse(stored) : [];
        }

        function saveWrongWords() {
            localStorage.setItem(WRONG_WORDS_KEY, JSON.stringify(state.wrongWords));
        }

        function commitWrongWordChanges() {
            let changed = false;
            for (const wordId in state.pendingWrongWordChanges) {
                const action = state.pendingWrongWordChanges[wordId];
                const wordExists = state.wrongWords.some(w => w.id === wordId);
                
                if (action === 'add' && !wordExists) {
                    const [level, ...meaningParts] = wordId.split('-');
                    const meaning = meaningParts.join('-');
                    const word = state.words[level.toLowerCase()].find(w => w.meaning === meaning);
                    if (word) state.wrongWords.push(word);
                    changed = true;
                } else if (action === 'remove' && wordExists) {
                    state.wrongWords = state.wrongWords.filter(w => w.id !== wordId);
                    changed = true;
                }
            }
            if(changed) saveWrongWords();
            state.pendingWrongWordChanges = {}; // Clear pending changes
        }

        // --- Event Handlers ---
        function setupEventListeners() {
            mainNavBtns.forEach(btn => btn.addEventListener('click', () => showScreen(btn.dataset.target)));
            backBtns.forEach(btn => btn.addEventListener('click', e => {
                commitWrongWordChanges(); // Save changes when leaving a word screen
                const target = e.currentTarget.dataset.target;
                if(target === 'memorize-select-screen') buildMemorizeScreen(); // Refresh screen
                if(target === 'test-select-screen') buildTestSelectScreen();
                showScreen(target);
            }));

            memorizeSelectContainer.addEventListener('click', e => {
                if (e.target.matches('.memorize-day-btn')) {
                    const { level, day } = e.target.dataset;
                    showMemorizeWords(level, day);
                }
                if (e.target.matches('.memorize-wrong-btn')) {
                    const { start, end } = e.target.dataset;
                    showMemorizeWords('wrong-note', null, parseInt(start), parseInt(end));
                }
            });

            testLevelGrid.addEventListener('click', e => {
                if(e.target.matches('.test-level-btn')) {
                    currentTestLevel = e.target.dataset.level;
                    setupTestRangeScreen(currentTestLevel);
                    showScreen('test-range-select-screen');
                }
            });
            
            document.getElementById('start-test-btn').addEventListener('click', handleStartTest);
        }

        function showMemorizeWords(level, day, start, end) {
            const container = document.getElementById('memorize-list-container');
            let wordsToShow;
            let title;
            let isWrongNoteMode = (level === 'wrong-note');

            if (isWrongNoteMode) {
                title = `오답노트 (${start + 1} - ${Math.min(end + 1, state.wrongWords.length)})`;
                wordsToShow = state.wrongWords.slice(start, end + 1);
            } else {
                title = `${level.toUpperCase()} ${day}일차 단어`;
                wordsToShow = state.words[level].filter(w => w.day == day);
            }

            document.getElementById('word-list-title').textContent = title;
            container.innerHTML = wordsToShow.length ? wordsToShow.map(word => {
                const isWrong = state.wrongWords.some(w => w.id === word.id);
                return `
                <div class="word-item flex justify-between items-center p-4 bg-white border rounded-lg shadow-sm ${isWrong ? 'is-wrong-note' : ''}" data-word-id="${word.id}">
                    <span class="text-slate-700">${word.meaning}</span>
                    <span class="text-sky-800 font-medium">${word.notation}</span>
                </div>`
            }).join('') : '<p class="text-center text-slate-500">표시할 단어가 없습니다.</p>';

            container.querySelectorAll('.word-item').forEach(el => {
                const word = wordsToShow.find(w => w.id === el.dataset.wordId);
                if (word) addSwipeListener(el, word, isWrongNoteMode);
            });
            showScreen('memorize-word-list-screen');
        }

        function setupTestRangeScreen(level) {
            // ... (No changes here)
        }

        function handleStartTest() {
            // ... (No changes here)
        }

        function displayTestWords(words, title, isWrongNoteTest) {
            const container = document.getElementById('test-list-container');
            document.getElementById('test-list-title').textContent = title;
            container.innerHTML = words.length ? words.map(word => {
                const isWrong = state.wrongWords.some(w => w.id === word.id);
                 return `
                <div class="word-item test-item-content p-4 bg-white border rounded-lg shadow-sm cursor-pointer ${isWrong ? 'is-wrong-note' : ''}" data-word-id="${word.id}">
                    <span class="text-slate-700">${word.meaning}</span>
                    <span class="notation text-sky-800 font-medium">${word.notation}</span>
                    <span class="placeholder text-slate-400">[클릭하여 정답 확인]</span>
                </div>`
            }).join('') : '<p class="text-center text-slate-500">테스트할 단어가 없습니다.</p>';

            container.querySelectorAll('.test-item-content').forEach(el => {
                el.addEventListener('click', () => el.classList.toggle('revealed'));
                
                if (!isWrongNoteTest) {
                    const word = words.find(w => w.id === el.dataset.wordId);
                    if (word) addSwipeListener(el, word, false);
                }
            });
            showScreen('test-word-list-screen');
        }

        // --- Swipe Logic ---
        function addSwipeListener(element, word) {
            let touchstartX = 0;
            let isProcessing = false;

            element.addEventListener('touchstart', e => {
                if (isProcessing) return;
                touchstartX = e.changedTouches[0].screenX;
            }, { passive: true });
            
            element.addEventListener('touchmove', e => {
                if (touchstartX === 0 || isProcessing) return;
                let deltaX = e.changedTouches[0].screenX - touchstartX;
                
                if (deltaX < -50) { // Swipe left
                    isProcessing = true;
                    touchstartX = 0; // Prevent re-triggering

                    // Toggle wrong note status
                    const isCurrentlyWrong = element.classList.toggle('is-wrong-note');
                    state.pendingWrongWordChanges[word.id] = isCurrentlyWrong ? 'add' : 'remove';

                    // Animate
                    element.classList.add('swiping');
                    setTimeout(() => {
                        element.classList.remove('swiping');
                        setTimeout(() => { isProcessing = false; }, 300); // Cooldown to prevent immediate re-swipe
                    }, 1000);
                }
            }, { passive: true });

            element.addEventListener('touchend', () => {
                touchstartX = 0;
            });
        }
    });
    </script>
</body>
</html>

